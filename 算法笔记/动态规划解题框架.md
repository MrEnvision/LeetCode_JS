# 动态规划解题框架

简介：本文主要介绍动态规划解题框架 ，完整笔记详见[算法专题](https://github.com/MrEnvision/LeetCode_JS)        

作者：[Envision](https://github.com/MrEnvision)         联系邮箱：[EnvisionShen@gmail.com](mailto:EnvisionShen@gmail.com)

参考资料：[动态规划详解](https://github.com/labuladong/fucking-algorithm/blob/master/动态规划系列/动态规划详解进阶.md)



动态规划一般形式就是**求最值问题**，核心就是穷举，穷举所有的可能性，然后找其中的最值得到结果，当然动态规划不是简单的穷举，其主要包含**3个特征**：

1. **存在重叠子问题**，穷举的过程中会有许多重复的行为，我们要做的就是避免这些重复；
2. **具备最优子结构**，动态规划问题一定能通过子问题的最值来得到最终的最终；
3. **状态转移方程**，我们需要写出状态转移方程来解决问题，写出这个方程，问题就解决了80%以上了；

那么如何写出状态转移方程呢？

```
明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case
```

举例 - leetcode322：

```
题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。

示例：k = 3，面值分别为 1，2，5，总金额 amount = 11，那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。
```

1. 明确状态：状态就是目标金额`n`；
2. 定义dp的含义：当前的目标金额是 `n`，至少需要 `dp(n)` 个硬币凑出该金额。
3. 明确选择：也就是对于每个状态，可以做出什么选择改变当前状态；具体到这个问题，选择就是从面额列表 `coins` 中选择一个硬币，然后目标金额就会减少；
4. 明确base case：目标金额为 0 时，所需硬币数量为 0，当目标金额小于 0 时，无解，返回 -1；

得到最后的状态转移方程：

<img src='https://github.com/labuladong/fucking-algorithm/raw/master/pictures/动态规划详解进阶/coin.png'>



解题模版：

```js
// 递归
function DP_question(n) {
    // 1.长度为状态数n+1的数组memo作为备忘记录
    // ...
    // 2.dp函数
    const dp = function (n, memo) {
        // 3.base case 也就是跳出递归的条件
        // ...
        // 4. 判断备忘录中是否有结果，如果有则直接返回
        // ...
        // 5.子问题的结果，然后合在一起处理
        // ...
        // 6.将n的结果存到备忘数组中，然后返回结果
        // ...
    }
    return dp(n, memo)
}

// 迭代
function DP_question(n) {
    // 1.长度为状态数n+1的数组memo作为备忘记录，根据需要设置index为0的值，一般设为0
    // ...
    // 2.DP table 自底向上推算
    for (let i = 0; i < n; i++) {
        // 3.利用前面的结果不断一步步处理后面
    }
    return memo[n]
}
```



备注1：建议使用DP table的方式，也就是迭代来实现动态规划，关于DP table的遍历无论正向、负向、还是斜着遍历都需要记住两点，**1、遍历的过程中，所需的状态必须是已经计算出来的；2、遍历的终点必须是存储结果的那个位置**。

备注2：一般求最值问题，都先往动态规划上去思考，先找到base case，然后往后推导找最优子结构，再根据最优子结构看有没有重叠子问题了，有则优化。

备注3：DP table并不一定直接就是结果，但是一定要能通过dp table计算出结果！



------

如果发现本项目有错误，欢迎提交 issues 指正。