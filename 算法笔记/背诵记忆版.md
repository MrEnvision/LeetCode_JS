# 【背诵记忆版】算法总结

简介：本文总结了算法常用思想以及解题框架 ，完整笔记详见[算法专题](https://github.com/MrEnvision/LeetCode_JS)        

作者：[SherwinShen](https://github.com/MrEnvision)         联系邮箱：[EnvisionShen@gmail.com](mailto:EnvisionShen@gmail.com)



## 遍历

```js
// 数组遍历
function traverse(array) {
  for (let i = 0; i < array.length; i++) {
    // 访问array[i]   
  }
}

// 链表遍历 - 迭代
function traverse(head) {
  while(p != null) {
    // 访问p.val
    p = p.next
  }
}
// 链表遍历 - 递归
function traverse(head) {
  if (head !== null) {
    // 访问head.val
    traverse(head.null)
  }
}

// 二叉树遍历 - 链表进阶
function traverse(head) {
  if(head !== null){
    // 前序遍历 head.val
    traverse(head.left)
    // 中序遍历 head.val
    traverse(head.right)
    // 后序遍历 head.val
  }
}

// n叉树遍历 - 二叉树进阶
function traverse(head) {
  if(head !== null){
    // 访问当前节点head.val
    for(let i=0;i<head.children.length;i++){
      traverse(this.head.children[i])
    }
  }
}
```

## 滑动窗口

```js
// 在S中找满足条件的内容
function slidingWindow(S) {
  let left = 0;
  let right = 0;

  // window 存储当前滑动窗口包含的内容
  // need 存储题目需要返回的结果

  while (right < S.length) {
    // window 添加 S[right] 的内容
    right++
    while (根据window存储的内容设置判断条件，视题目而定) {
      // window 删除S[left] 的内容
      left++
    }
  }

  // 此时right已指向最后，视题意决定left指针是否继续往右滑动

  return need // 返回数据need视题目而定，也需要在前面过程中视题目而处理
}
```

## 回溯算法

> 记住三个关键点：结束条件，已选路径，可选路径。

```js
function func(){
  let result = []
  const backtrack = function(路径, 选择列表){
    // 结束条件
    if(满足结束条件){
      result.push(路径)
      return
    }
    // 进行选择
    for(let 选择 of 选择列表){
      // 做选择加入路径
      路径.push(选择)
      // 进入下一层
      backtrack(路径, 选择列表)
      // 撤销选择，进行for循环的下一轮，注意，不要忘记这一步！！！
      路径.pop(选择)
    } 
  }
  backtrack(初始路径, 初始选择列表)
  return result
}
```

## 二分查找

> 常见应用场景：**查找一个数、寻找左侧边界、寻找右侧边界**。二分查找的解题关键在于**「搜索区间」**，通过左右指针来确定区间。

```js
function binarySearch(nums, target) {
  let left = 0;
  let right = nums.length -1;
  while(left <= right) {
    let mid = Math.floor((left + right)/2)
    if(num[mid] === target) {
      return mid
    } else if(nums[mid] < target) {
      left = mid + 1;
    } else if(nums[mid] > target) {
      right = mid - 1; 
    }
  }
  return -1;    
}
```

## 动态规划

> 记住3个关键点：存在重叠子问题、具备最优子结构和状态转移方程，只要存在这三个特征的就利用动态规划解决。
>
> 动态规划的最核心在于状态转移方程，明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。
>
> ⚠️ 个人建议使用DP table的方式，也就是迭代来实现动态规划。

```js
// 迭代
function DP_question(n) {
  // 1.长度为状态数n+1的数组memo作为备忘记录，根据需要设置index为0的值，一般设为0
  // ...
  // 2.DP table 自底向上推算
  for (let i = 0; i < n; i++) {
    // 3.利用前面的结果不断一步步处理后面
  }
  return memo[n]
}
```

## 双指针

> 主要分为「快慢指针」和「左右指针」来解题。

## 分治/递归算法

>分治问题一般分三步走，大问题分解小问题 -> 解决小问题(一般是递归结束条件) -> 合并小问题
>
>递归问题右两个关键点，一是结束条件，而是不断调用自身。



------

如果发现本项目有错误，欢迎提交 issues 指正。